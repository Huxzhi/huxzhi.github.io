{
  "posts": [
    {
      "title": "CLS偏移问题",
      "slug": "cls",
      "tags": [
        "HTML",
        "HTML/cls"
      ],
      "created": "2025-09-05T09:05",
      "updated": "2026-01-15T14:57",
      "draft": false,
      "wordCount": 973,
      "outLinks": [
        "https://blog.skk.moe/post/fix-blog-cls/"
      ],
      "path": "post/CLS偏移问题.md",
      "aliases": [],
      "description": "#HTML/cls\r\n\r\n[优化博客的累计布局偏移（CLS）问题](https://blog.skk.moe/post/fix-blog-cls/)\r\n\r\n> 什么是 CLS？ 当用户浏览一个页面的时候，若是想要点击一个按钮或者其他交互时，页面的布局突然出然抖动，可以会造成用户的交互行为造成期望之外的结果。大多数情况下，这些体验只是令人恼火——用户不得不返回上一个页面，但在某些情况下，后果有可能非常严重： Google 针对这种页面布局抖动，提供了一系列计算公式，用于衡量和标准化一个页面的抖动对用户体验的影响，这就是 CLS（Cumulative Layout Shift，累计布局偏移）。CLS 是 Google 衡量网站用户体验的指标 Web Vitals 之一。\r\n>\r\n> 但是由于我的响应式布局需要同时考虑移动端和桌面端的体验，因此我不得不将的 main 放置在最前面。不过，我还是实现了一个 workaround，在前面插入一个 100% 宽度 0 高度的空 div 元素：\r\n\r\n实际操作还是有点问题,加这个 col-start-1 有问题，目前没有加\r\n\r\n```html\r\n<div\r\n  class=\"min-h-screen max-w-[992px] grid mx-auto gap-6 py-6 px-4 md:grid-cols-[12fr_25fr] xl:grid-cols-[23fr_54fr_23fr] xl:max-w-[1376px]\"\r\n>\r\n  <!-- 为了解决cls 累计布局偏移（CLS）问题 ，目前内容少还没有发现有这个问题\r\n        加这个 col-start-1 有问题，目前没有加 https://blog.skk.moe/post/fix-blog-cls/ -->\r\n\r\n  <div class=\"left-placeholder col-end-1 -order-1 max-h-0 min-w-0 h-0\"></div>\r\n  <main class=\"flex flex-col order-first md:order-0 min-w-0\">\r\n    <slot />\r\n  </main>\r\n  <aside class=\"min-w-0 -order-1 max-md:order-1\">\r\n    <slot name=\"left\" />\r\n  </aside>\r\n  <aside class=\"min-w-0 order-1 max-xl:hidden\">\r\n    <slot name=\"right\" />\r\n  </aside>\r\n</div>\r\n```",
      "outlinks": [
        "https://blog.skk.moe/post/fix-blog-cls/"
      ]
    },
    {
      "title": "View Transitions 使用指南",
      "slug": "view-transitions",
      "tags": [
        "Astro",
        "Astro/view"
      ],
      "created": "2025-09-05T09:05",
      "updated": "2026-01-15T14:57",
      "draft": false,
      "wordCount": 539,
      "outLinks": [
        "内容访问层架构说明"
      ],
      "aliases": [
        "view-transitions"
      ],
      "path": "post/view-transitions.md",
      "description": "# View Transitions 使用指南\r\n\r\n本项目已启用 Astro View Transitions，提供平滑的页面切换体验。\r\n\r\n```html\r\n<ClientRouter />\r\n```\r\n\r\n#Astro/view-transitions\r\n\r\n> 启用视图过渡动画（SPA 模式）\r\n> 导入 `<ClientRouter />` 组件并将其添加到公共 `<head>` 或共享布局组件中。Astro 将根据旧页面和新页面之间的相似之处创建默认的页面动画，并为不支持的浏览器提供回退行为。\r\n> 》\r\n> **这带来了一些好处，比如跨页面的共享状态和持久化元素，也有一些缺点，例如在导航后需要手动重新初始化脚本或状态。**\r\n>\r\n> 然而，随着浏览器 API 和 web 标准的不断发展，使用 Astro 的 `<ClientRouter />` 来实现这些附加功能 **将越来越变得不必要**。我们建议你关注浏览器 API 的当前状态，以便你可以根据你使用的特定功能决定是否仍然需要 Astro 的客户端路由。\r\n\r\n## 遇到问题\r\n\r\n遇到一个问题 我的 `<auth/>` 组件在第一次加载时会加载，但是页面切换后不会加载，马上就锁定到是 平滑的页面切换体验 的问题，查了官网\r\n\r\n```html\r\n<div\r\n  id=\"auth\"\r\n  transition:persist\r\n></div>\r\n```\r\n\r\n[[内容访问层架构说明]]",
      "outlinks": [
        "内容访问层架构说明"
      ]
    },
    {
      "title": "内容访问层架构说明",
      "slug": "contents",
      "created": "2025-09-05T09:05",
      "updated": "2026-01-15T14:57",
      "draft": false,
      "wordCount": 3633,
      "path": "post/内容访问层架构说明.md",
      "aliases": [],
      "description": "# 内容访问层架构说明\r\n\r\n## 概述\r\n\r\n项目采用**双层适配器模式**来支持开发和生产环境的不同数据源：\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────┐\r\n│                      应用层                              │\r\n│  (页面组件、API 路由)                                    │\r\n└─────────────────────────────────────────────────────────┘\r\n                         ↓\r\n         ┌───────────────┴───────────────┐\r\n         ↓                               ↓\r\n┌──────────────────┐           ┌──────────────────┐\r\n│  服务端访问层     │           │  客户端访问层     │\r\n│ (SSR/SSG)        │           │  (编辑器)        │\r\n└──────────────────┘           └──────────────────┘\r\n         ↓                               ↓\r\n  src/adapter/content.ts        src/adapter/index.ts\r\n         ↓                               ↓\r\n  Astro Content API              ┌──────┴──────┐\r\n         ↓                       ↓             ↓\r\n  src/content/posts/      FSAdapter     GithubAdapter\r\n                               ↓             ↓\r\n                          本地 API      GitHub API\r\n```\r\n\r\n## 架构组成\r\n\r\n### 1. 服务端内容访问层 (`src/adapter/content.ts`)\r\n\r\n**用途**: SSR/SSG 页面渲染时访问内容\r\n\r\n**特点**:\r\n\r\n- 统一封装 Astro Content Collections API\r\n- 提供类型安全的查询方法\r\n- 便于未来切换数据源（如从 GitHub API 直接读取）\r\n\r\n**核心方法**:\r\n\r\n```typescript\r\ngetAllPosts() // 获取所有文章\r\ngetPostById(id) // 获取单篇文章\r\ngetPostsByTag(tag) // 按标签过滤\r\ngetPostsByCategory(cat) // 按分类过滤\r\ngetAllTags() // 获取所有标签\r\ngetAllCategories() // 获取所有分类\r\ntoPageData(entry) // 转换为统一格式\r\n```\r\n\r\n**使用场景**:\r\n\r\n- Astro 页面组件 (`.astro` 文件)\r\n- API 路由 (`/api/**/*.ts`)\r\n- 静态生成 (SSG)\r\n\r\n### 2. 客户端编辑器访问层 (`src/adapter/index.ts`)\r\n\r\n**用途**: 浏览器端编辑器的 CRUD 操作\r\n\r\n**环境切换**:\r\n\r\n```typescript\r\nconst adapter = import.meta.env.DEV ? FSAdapter : GithubAdapter\r\n```\r\n\r\n**适配器对比**:\r\n\r\n| 功能 | FSAdapter (开发)        | GithubAdapter (生产) |\r\n| ---- | ----------------------- | -------------------- |\r\n| 读取 | `GET /api/post/[id]`    | GitHub API           |\r\n| 保存 | `POST /api/post/[id]`   | GitHub API           |\r\n| 删除 | `DELETE /api/post/[id]` | GitHub API           |\r\n| 认证 | 无需                    | GitHub Token         |\r\n\r\n**核心方法**:\r\n\r\n```typescript\r\nreadPageByPath(path) // 读取文章\r\nwritePage(path, data, assets) // 保存文章\r\ndeletePageByPath(path, assets) // 删除文章\r\n```\r\n\r\n## 数据流\r\n\r\n### 开发环境\r\n\r\n```\r\n编辑器 → FSAdapter → 本地 API → 本地文件系统\r\n          ↓\r\n      读/写 .md 文件\r\n          ↓\r\n  Astro Content Collections\r\n          ↓\r\n      页面渲染\r\n```\r\n\r\n### 生产环境\r\n\r\n```\r\n页面渲染:\r\n  Astro → content.ts → Content Collections → 本地 .md 文件\r\n\r\n编辑器:\r\n  编辑器 → GithubAdapter → GitHub API → GitHub 仓库\r\n```\r\n\r\n## 优势\r\n\r\n### ✅ 统一接口\r\n\r\n- 应用层代码不关心具体数据源\r\n- 便于切换实现\r\n\r\n### ✅ 类型安全\r\n\r\n- 统一的 `PageData` 类型\r\n- TypeScript 全链路支持\r\n\r\n### ✅ 环境隔离\r\n\r\n- 开发环境使用本地文件系统，快速迭代\r\n- 生产环境直接操作 GitHub，无需部署\r\n\r\n### ✅ 可扩展\r\n\r\n- 未来可添加其他数据源（CMS、数据库等）\r\n- 只需实现相同接口\r\n\r\n## 使用示例\r\n\r\n### 在 Astro 页面中使用\r\n\r\n```astro\r\n---\r\nimport { getAllPosts } from '@/adapter/content'\r\n\r\n// 获取所有已发布的文章\r\nconst allPosts = await getAllPosts()\r\nconst publishedPosts = allPosts.filter(p => !p.data.draft)\r\n---\r\n\r\n<div>\r\n  {publishedPosts.map(post => (\r\n    <article>\r\n      <h2>{post.data.title}</h2>\r\n      <p>{post.body.slice(0, 100)}...</p>\r\n    </article>\r\n  ))}\r\n</div>\r\n```\r\n\r\n### 在 API 路由中使用\r\n\r\n```typescript\r\nimport { getPostById, toPageData } from '@/adapter/content'\r\n\r\nexport const GET: APIRoute = async ({ params }) => {\r\n  const post = await getPostById(params.id!)\r\n  if (!post) {\r\n    return new Response(JSON.stringify({ error: 'Not found' }), { status: 404 })\r\n  }\r\n  return new Response(JSON.stringify(toPageData(post)))\r\n}\r\n```\r\n\r\n### 在编辑器中使用\r\n\r\n```typescript\r\nimport adapter from '@/adapter'\r\n\r\n// 读取文章\r\nconst post = await adapter.readPageByPath('my-post')\r\n\r\n// 保存文章\r\nawait adapter.writePage(\r\n  'my-post',\r\n  {\r\n    content: '# Hello',\r\n    title: 'My Post',\r\n    tags: ['tech'],\r\n    createTime: Date.now(),\r\n    draft: false,\r\n  },\r\n  [],\r\n)\r\n```\r\n\r\n## 未来扩展方向\r\n\r\n### 方案 1: 生产环境也使用 GitHub API 渲染\r\n\r\n```typescript\r\n// src/adapter/content.ts\r\nexport async function getAllPosts() {\r\n  if (import.meta.env.PROD && USE_GITHUB_API) {\r\n    // 从 GitHub API 读取\r\n    return fetchPostsFromGitHub()\r\n  }\r\n  // 默认使用 Content Collections\r\n  return await getCollection('posts')\r\n}\r\n```\r\n\r\n### 方案 2: 支持多数据源\r\n\r\n```typescript\r\n// src/adapter/content.ts\r\nconst dataSource = import.meta.env.DATA_SOURCE // 'local' | 'github' | 'cms'\r\n\r\nexport async function getAllPosts() {\r\n  switch (dataSource) {\r\n    case 'github':\r\n      return await fetchFromGitHub()\r\n    case 'cms':\r\n      return await fetchFromCMS()\r\n    default:\r\n      return await getCollection('posts')\r\n  }\r\n}\r\n```\r\n\r\n### 方案 3: 混合模式\r\n\r\n```typescript\r\n// 构建时从 GitHub 拉取，运行时使用本地缓存\r\nexport async function getAllPosts() {\r\n  if (import.meta.env.BUILD_TIME) {\r\n    await syncFromGitHub() // 构建时同步\r\n  }\r\n  return await getCollection('posts') // 运行时读取本地\r\n}\r\n```\r\n\r\n## 注意事项\r\n\r\n1. **生产环境限制**: 当前生产环境页面渲染仍依赖本地 `src/content/posts/` 文件\r\n2. **编辑器独立**: 编辑器在生产环境直接操作 GitHub，不影响已部署的页面\r\n3. **数据一致性**: 需要在部署时确保 GitHub 仓库和部署的文件同步\r\n4. **认证管理**: GitHub 适配器需要用户提供有效的 Personal Access Token\r\n\r\n## 相关文件\r\n\r\n- `src/adapter/content.ts` - 服务端内容访问层\r\n- `src/adapter/index.ts` - 客户端适配器选择器\r\n- `src/adapter/fs/index.ts` - 本地文件系统适配器\r\n- `src/adapter/github/index.ts` - GitHub API 适配器\r\n- `src/adapter/helper.ts` - 类型定义\r\n- `src/shared/type.ts` - 数据模型定义",
      "inlinks": [
        "view-transitions"
      ]
    }
  ]
}