const e=JSON.parse('{"key":"v-b143800e","path":"/code/language/typescript/%E5%B0%8F%E6%BB%A1TypeScript%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/11-namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html","title":"11-namespace命名空间","lang":"zh-CN","frontmatter":{"date":"2022-12-31 15:53","title":"11-namespace命名空间","description":"我们在工作中无法避免全局变量造成的污染，TypeScript 提供了 namespace 避免这个问题出现 内部模块，主要用于组织代码，避免命名冲突。 命名空间内的类默认私有 通过 export 暴露 通过 namespace 关键字定义 TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 import 或者 export 声明，那么它的内容被视为全局可见的（因此对模块也是可见的）","head":[["meta",{"property":"og:url","content":"https://huxzhi.github.io/code/language/typescript/%E5%B0%8F%E6%BB%A1TypeScript%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/11-namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html"}],["meta",{"property":"og:site_name","content":"Huxzhiの小站"}],["meta",{"property":"og:title","content":"11-namespace命名空间"}],["meta",{"property":"og:description","content":"我们在工作中无法避免全局变量造成的污染，TypeScript 提供了 namespace 避免这个问题出现 内部模块，主要用于组织代码，避免命名冲突。 命名空间内的类默认私有 通过 export 暴露 通过 namespace 关键字定义 TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 import 或者 export 声明，那么它的内容被视为全局可见的（因此对模块也是可见的）"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-04T10:07:31.000Z"}],["meta",{"property":"article:published_time","content":"2022-12-31T15:53:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-04T10:07:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"11-namespace命名空间\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-12-31T15:53:00.000Z\\",\\"dateModified\\":\\"2023-03-04T10:07:31.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"嵌套命名空间","slug":"嵌套命名空间","link":"#嵌套命名空间","children":[]},{"level":2,"title":"抽离命名空间","slug":"抽离命名空间","link":"#抽离命名空间","children":[]},{"level":2,"title":"简化命名空间","slug":"简化命名空间","link":"#简化命名空间","children":[]},{"level":2,"title":"合并命名空间","slug":"合并命名空间","link":"#合并命名空间","children":[]}],"git":{"createdTime":1677924451000,"updatedTime":1677924451000,"contributors":[{"name":"Huxzhi","email":"huxzhi@gmail.com","commits":1}]},"readingTime":{"minutes":0.84,"words":251},"filePathRelative":"code/language/typescript/小满TypeScript基础教学/11-namespace命名空间.md","localizedDate":"2022年12月31日","excerpt":"<p>我们在工作中无法避免全局变量造成的污染，TypeScript 提供了 namespace 避免这个问题出现</p>\\n<ul>\\n<li>内部模块，主要用于组织代码，避免命名冲突。</li>\\n<li>命名空间内的类默认私有</li>\\n<li>通过 export 暴露</li>\\n<li>通过 namespace 关键字定义</li>\\n</ul>\\n<p><mark>TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 import 或者 export 声明，那么它的内容被视为全局可见的（因此对模块也是可见的）</mark></p>","copyright":{},"autoDesc":true}');export{e as data};
