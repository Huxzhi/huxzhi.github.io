import{_ as d,W as o,X as c,Y as i,a0 as a,a1 as l,a2 as e,y as r,Z as s}from"./framework-cbb69da9.js";const n={},p=e('<h1 id="vite-目录" tabindex="-1"><a class="header-anchor" href="#vite-目录" aria-hidden="true">#</a> Vite 目录</h1><p><code>public</code> 下面的不会被编译 可以存放静态资源</p><p><code>assets</code> 下面可以存放可编译的静态资源</p><p><code>components</code> 下面用来存放我们的组件</p><p><code>App.vue</code> 是全局组件</p><p><code>main.ts</code> 全局的ts文件</p><p><code>index.html</code> 非常重要的入口文件 （webpack，rollup 他们的入口文件都是enrty input 是一个js文件 而Vite 的入口文件是一个html文件，他刚开始不会编译这些js文件 只有当你用到的时候 如 <code>script src=&quot;xxxxx.js&quot;</code> 会发起一个请求被vite拦截这时候才会解析js文件）</p><p><code>vite config ts</code> 这是vite的配置文件具体配置项 后面会详解</p><p><code>VsCode</code> Vue3 插件推荐 <code>Vue Language Features (Volar)</code></p><h1 id="sfc-语法规范" tabindex="-1"><a class="header-anchor" href="#sfc-语法规范" aria-hidden="true">#</a> SFC 语法规范</h1><p><code>*.vue</code> 件都由三种类型的顶层语法块所组成：<code>&lt;template&gt;、&lt;script&gt;、&lt;style&gt;</code></p><h3 id="template" tabindex="-1"><a class="header-anchor" href="#template" aria-hidden="true">#</a> <code>&lt;template&gt;</code></h3><ul><li>每个 <code>*.vue</code> 文件最多可同时包含一个顶层 <code>&lt;template&gt;</code> 块。</li><li>其中的内容会被提取出来并传递给 @vue/compiler-dom，预编译为 JavaScript 的渲染函数，并附属到导出的组件上作为其 render 选项。</li></ul><hr><h3 id="script" tabindex="-1"><a class="header-anchor" href="#script" aria-hidden="true">#</a> <code>&lt;script&gt;</code></h3><ul><li>每一个 <code>*.vue</code> 文件可以有多个 <code>&lt;script&gt;</code> 块 (不包括<code>&lt;script setup&gt;</code>)。</li><li>该脚本将作为 <code>ES Module</code> 来执行。</li><li>其默认导出的内容应该是 <code>Vue</code> 组件选项对象，它要么是一个普通的对象，要么是 <code>defineComponent</code> 的返回值。</li></ul><hr><h3 id="script-setup" tabindex="-1"><a class="header-anchor" href="#script-setup" aria-hidden="true">#</a> <code>&lt;script setup&gt;</code></h3>',18),u=e('<ul><li>每个 <code>*.vue</code> 文件最多只能有一个 <code>&lt;script setup&gt;</code> 块 (不包括常规的 <code>&lt;script&gt;</code>)</li><li>该脚本会被预处理并作为组件的 <code>setup()</code> 函数使用，也就是说它会在每个组件实例中执行。<code>&lt;script setup&gt;</code> 的顶层绑定会自动暴露给模板。更多详情请查看 <code>&lt;script setup&gt;</code> 文档。</li></ul><hr><h3 id="style" tabindex="-1"><a class="header-anchor" href="#style" aria-hidden="true">#</a> <code>&lt;style&gt;</code></h3><ul><li>一个 <code>*.vue</code> 文件可以包含多个 <code>&lt;style&gt;</code> 标签。</li><li><code>&lt;style&gt;</code> 标签可以通过 <code>scoped</code> 或 <code>module attribute</code> (更多详情请查看 SFC 样式特性) 将样式封装在当前组件内。多个不同封装模式的 <code>&lt;style&gt;</code> 标签可以在同一个组件中混</li></ul><hr><h1 id="npm-run-dev-详解" tabindex="-1"><a class="header-anchor" href="#npm-run-dev-详解" aria-hidden="true">#</a> npm run dev 详解</h1><p><code>npm run xxx</code> 的时候，就会到 <code>node_modules/bin</code> 中找对应的映射文件，然后再找到相应的 js 文件来执行</p><ol><li>查找规则是先从当前项目的 <code>node_modlue /bin</code> 去找,</li><li>找不到去全局的 <code>node_module/bin</code> 去</li><li>再找不到去 环境变量 去找</li></ol>',8);function h(_,m){const t=r("RouterLink");return o(),c("div",null,[p,i("p",null,[a(t,{to:"/zh/posts/literature-notes/xiaoman-zsVue3-vite-Ts/Setup%E8%AF%AD%E6%B3%95%E7%B3%96.html"},{default:l(()=>[s("Setup 语法糖")]),_:1})]),u])}const x=d(n,[["render",h],["__file","02-Vite目录和Vue单文件组件和npm run dev 详解.html.vue"]]);export{x as default};
