import{_ as r,X as e,Y as a,a2 as n}from"./framework-c2b0d87a.js";const t={},s=n('<h1 id="数据链路层" tabindex="-1"><a class="header-anchor" href="#数据链路层" aria-hidden="true">#</a> 数据链路层</h1><h2 id="封装成帧" tabindex="-1"><a class="header-anchor" href="#封装成帧" aria-hidden="true">#</a> 封装成帧</h2><p>进行帧定界</p><p>每一种链路层协议都规定了所能传送的帧的<strong>数据部分长度的上限——最大传送单元MTU（Maximum Transfer Unit）</strong></p><p>帧定界符 控制字符 SOH （Start Of Header）0x01 （二进制是00000001）帧开始符 控制字符 EOT （End Of Transmission）0x04（二进制是00000100）帧结束符</p><h2 id="差错控制" tabindex="-1"><a class="header-anchor" href="#差错控制" aria-hidden="true">#</a> 差错控制</h2><p>比特在传输过程中可能会产生差错：1可能会变成0，而0变成1，这就叫<strong>比特差错</strong>。</p><p><strong>循环冗余检验CRC（Cyclic Redundancy Check）<strong>是一种</strong>检测方法</strong></p><p><strong>帧检验序列FCS（Frame Check Sequence）<strong>是添加在数据后面的</strong>冗余码</strong></p><p>只能做到对帧的无差错接受，不能做到<strong>传输差错</strong>，现在已改由上层协议（例如运输层的TCP协议）来完成</p><p>传输错误：帧丢失，帧重复，帧失序</p><h2 id="透明传输" tabindex="-1"><a class="header-anchor" href="#透明传输" aria-hidden="true">#</a> 透明传输</h2><p>在发送端的数据链路层在数据中出现控制字符“SOH”或者“EOT”的前面插入一个<strong>转义字符“ESC”</strong>（0x1B，二进制是00011011）。接收端的数据链路层在数据送往网络层之前删除这个插入的转义字符。这种方法称为<strong>字节填充（byte stuffing</strong>）或<strong>字符填充（character stuffing）</strong>。</p><p>如果转义字符也出现在数据中，解决方法仍然是在转义字符的前面插入一个转义字符，接收端收到连续两个转义字符时，就删除其中前面一个</p><h4 id="点对点协议ppp" tabindex="-1"><a class="header-anchor" href="#点对点协议ppp" aria-hidden="true">#</a> 点对点协议PPP</h4>',15),o=[s];function h(d,i){return e(),a("div",null,o)}const p=r(t,[["render",h],["__file","数据链路层.html.vue"]]);export{p as default};
