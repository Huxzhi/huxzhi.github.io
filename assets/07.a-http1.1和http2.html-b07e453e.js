import{_ as o,X as d,Y as i,Z as e,$ as p,a1 as c,a2 as a,G as r}from"./framework-c2b0d87a.js";const n="/assets/image-2023-01-26_17-41-06-767-07.a-http1.1和http2-4ff058b3.png",s="/assets/image-2023-01-26_17-41-43-846-07.a-http1.1和http2-106ea865.png",h="/assets/image-2023-01-26_17-43-09-882-07.a-http1.1和http2-c7a6c62c.png",f={},l=a('<h1 id="http1-1-http2" tabindex="-1"><a class="header-anchor" href="#http1-1-http2" aria-hidden="true">#</a> http1.1 http2</h1><p>HTTP/2 采用二进制格式而非文本格式 HTTP/2 是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行 使用报头压缩，HTTP/2 降低了开销 HTTP/2 让服务器可以将响应主动“推送”到客户端缓存中</p><h2 id="_1-二进制分帧层" tabindex="-1"><a class="header-anchor" href="#_1-二进制分帧层" aria-hidden="true">#</a> 1.二进制分帧层</h2><p>在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>2.多路复用 <img src="'+s+'" alt="" loading="lazy"></p><p>从上图可以看出，HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时间</p><p>3.头部压缩 <img src="'+h+'" alt="" loading="lazy"></p><ul><li>维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合</li><li>维护一份相同的动态字典，可以动态的添加内容</li><li>通过静态 Huffman 编码对传输的首部字段进行编码</li></ul>',9),_={href:"https://http2.akamai.com/demo",title:"演示demoHTTP/2: the Future of the Internet | Akamai",target:"_blank",rel:"noopener noreferrer"},g=a('<h2 id="_4-客户端缓存" tabindex="-1"><a class="header-anchor" href="#_4-客户端缓存" aria-hidden="true">#</a> 4.客户端缓存</h2><h3 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a> 协商缓存</h3><p>协商缓存就是通过服务器来判断缓存是否可用</p><p><code>Last-Modify</code> 搭配 <code>If-Modify-Since:</code> 浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是该资源的最后修改时间；当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值服务端 header 中返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存</p><p>Etag 搭配 If-None-Match：web 服务器响应请求时，会在 header 中加一个 Etag 用来告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。则再次向 web 服务器请求时带上头 If-None-Match （Etag 的值）。web 服务器收到请求后将 If-None-Match 与 Etag 进行比对，决定是否命中协商缓存；</p><p><code>ETag</code> 和 <code>Last-Modified</code> 的作用和用法，他们的区别：</p><p>1.Etag 要优于 Last-Modified。Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；</p><p>2.在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值；</p><p>3.在优先级上，服务器校验优先考虑 Etag。</p><p>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200</p><h3 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存" aria-hidden="true">#</a> 强缓存</h3><p>Expires:值为绝对时间，不过 Expires 是 HTTP 1.0 的东西，现在默认浏览器均默认使用 HTTP 1.1</p><p><code>Cache-Control:</code>值为相对时间，如果与 Expires 同时设置的话，其优先级高于 Expires。</p><p><code>cache-control</code> 有下面几个比较常用的设置值:</p><p><code>-max-age:</code> 设置失效时间，客户端在这个有效期内，如果又请求该资源，就直接读取缓存</p><p><code>-no-cache:</code> 不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则从缓存中取数据</p><p><code>-no-store:</code> 直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求。</p><p><code>-public:</code> 可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。</p><p><code>-private:</code> 只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。</p><p>服务器通过设置 http 中 hdader 的 Expires 和 cache-control 字段告诉浏览器换存的有效期。这种方法会有一个固定时间，所带来的问题是如果服务器数据进行了更新，但是还没有到强缓存的过期时间，则数据无法更新</p>',20);function m(T,u){const t=r("ExternalLinkIcon");return d(),i("div",null,[l,e("p",null,[e("a",_,[p("演示 demoHTTP/2: the Future of the Internet | Akamai"),c(t)])]),g])}const x=o(f,[["render",m],["__file","07.a-http1.1和http2.html.vue"]]);export{x as default};
