import{_ as e,X as a,Y as t,a2 as i}from"./framework-c2b0d87a.js";const o="/assets/image-2023-01-09_15-58-11-459-35-EvnetLoop-and-nextTick-3704d9f1.png",r="/assets/image-2023-01-09_16-01-43-181-35-EvnetLoop-and-nextTick-9d98552d.png",s={},n=i('<h2 id="js-执行机制" tabindex="-1"><a class="header-anchor" href="#js-执行机制" aria-hidden="true">#</a> JS 执行机制</h2><p>在我们学 js 的时候都知道 js 是单线程的如果是多线程的话会引发一个问题在同一时间同时操作 DOM 一个增加一个删除 JS 就不知道到底要干嘛了，所以这个语言是单线程的但是随着 HTML5 到来 js 也支持了多线程 webWorker 但是也是不允许操作 DOM</p><p>单线程就意味着所有的任务都需要排队，后面的任务需要等前面的任务执行完才能执行，如果前面的任务耗时过长，后面的任务就需要一直等，一些从用户角度上不需要等待的任务就会一直等待，这个从体验角度上来讲是不可接受的，所以 JS 中就出现了异步的概念。</p><h2 id="同步任务" tabindex="-1"><a class="header-anchor" href="#同步任务" aria-hidden="true">#</a> 同步任务</h2><p>代码从上到下按顺序执行</p><h2 id="异步任务" tabindex="-1"><a class="header-anchor" href="#异步任务" aria-hidden="true">#</a> 异步任务</h2><h3 id="_1-宏任务" tabindex="-1"><a class="header-anchor" href="#_1-宏任务" aria-hidden="true">#</a> 1.宏任务</h3><p>script(整体代码)、setTimeout、setInterval、UI 交互事件、postMessage、Ajax</p><h3 id="_2-微任务" tabindex="-1"><a class="header-anchor" href="#_2-微任务" aria-hidden="true">#</a> 2.微任务</h3><p><code>Promise.then</code>(Promise 构造函数是宏任务) <code>catch</code> <code>finally</code>、<code>MutaionObserver</code>、<code>process.nextTick</code>(Node.js 环境)</p><p>运行机制</p><p>所有的同步任务都是在主进程执行的形成一个执行栈，主线程之外，还存在一个&quot;任务队列&quot;，异步任务执行队列中先执行宏任务，然后清空当次宏任务中的所有微任务，然后进行下一个 tick 如此形成循环。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上到下解析，1.两个setTimeout放到宏任务队列 2. 4个promise放到微任务队列 3.执行Prom，其中X放到微任务队列末尾。所以X在5 6 7 8后面</p>',15),c=[n];function d(h,p){return a(),t("div",null,c)}const l=e(s,[["render",d],["__file","35-Evnet Loop和执行机制.html.vue"]]);export{l as default};
