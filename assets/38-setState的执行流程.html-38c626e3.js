import{_ as e,X as s,Y as t,Z as c,$ as n,a1 as i,a3 as o,a2 as l,G as p}from"./framework-c2b0d87a.js";const u={},d=l(`<h1 id="_38-setstate-的执行流程" tabindex="-1"><a class="header-anchor" href="#_38-setstate-的执行流程" aria-hidden="true">#</a> 38-setState 的执行流程</h1><p><code>Too many re-renders.</code></p><ul><li>当我们直接在函数体中调用 setState 时，就会触发上述错误</li><li>问题： 不是说过，当新的 state 值和旧值相同时，它是不会触发组件的重新渲染的</li></ul><h2 id="setstate-的执行流程-函数组件" tabindex="-1"><a class="header-anchor" href="#setstate-的执行流程-函数组件" aria-hidden="true">#</a> setState()的执行流程（函数组件）</h2><p><code>setCount()</code> --&gt; <code>dispatchSetDate()</code> --&gt; 会先判断，组件当前处于什么阶段</p><ul><li><mark>如果是渲染阶段 --&gt; 不会检查 state 值是否相同</mark></li><li>如果不是渲染阶段 --&gt; 会检查 state 的值是否相同 <ul><li>如果值不相同，则对组件进行重新渲染</li><li>如果值相同，则不对组件进行重新渲染 如果值相同，React 在一些情况下会继续执行当前组件的渲染 但是这个渲染不会触发其子组件的渲染，这次渲染不会产生实际的效果 这种情况通常发生在值第一次相同时</li></ul></li></ul><blockquote><p>渲染阶段为，函数返回 return <code>&lt;div&gt;...&lt;/div&gt;</code> 之前</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>count 0
    第一次点击按钮 count 0 --&gt; 1
        &#39;App组件重新渲染了！&#39; 执行了
    第二次点击按钮 count 1 --&gt; 1
        &#39;App组件重新渲染了！&#39; 执行了
    第三次点击按钮 count 1 --&gt; 1
        &#39;App组件重新渲染了！&#39; 没执行
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="解决办法" tabindex="-1"><a class="header-anchor" href="#解决办法" aria-hidden="true">#</a> 解决办法</h2><p>临时解决，用定时器，因为是异步函数，必须等主线程执行完后才进行</p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,11);function r(v,k){const a=p("RouterLink");return s(),t("div",null,[d,c("p",null,[n("更好的解决办法： "),i(a,{to:"/code/react/React18/39-useEffect%E5%89%AF%E4%BD%9C%E7%94%A8-%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%90%8E%E6%89%A7%E8%A1%8C.html"},{default:o(()=>[n("39-useEffect副作用-组件渲染后执行")]),_:1})])])}const h=e(u,[["render",r],["__file","38-setState的执行流程.html.vue"]]);export{h as default};
