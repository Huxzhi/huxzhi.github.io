import{_ as a,X as t,Y as o,Z as n,$ as e,a1 as c,a2 as p,G as i}from"./framework-c2b0d87a.js";const d={},l=p(`<h1 id="_37-too-many-re-renders" tabindex="-1"><a class="header-anchor" href="#_37-too-many-re-renders" aria-hidden="true">#</a> 37-Too many re-renders</h1><p>React 组件有部分逻辑都可以直接编写到组件的函数体中的，像是对数组调用 filter、map 等方法，像是判断某个组件是否显示等。但是有一部分逻辑如果直接写在函数体中，会影响到组件的渲染，这部分会产生“副作用”的代码，是一定不能直接写在函数体中。</p><p>例如，<mark>如果直接将修改 state 的逻辑编写到了组件之中，就会导致组件不断的循环渲染，直至调用次数过多内存溢出。</mark></p><p>在组件每次重新渲染的时候，检查一下商品的总数量，如果数量为 0，则修改 showDetails 为 false</p><p>组件每次重新渲染，组件的函数体就会执行，</p><p>以下代码会报错 (<code>Too many re-renders.</code> )</p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>CartContext<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 添加一个state 设置结账页的显示于隐藏</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>showCheckout<span class="token punctuation">,</span> setShowCheckout<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span> initialState<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在组件每次重新渲染的时候，检查一下商品的总数量，如果数量为0，则修改showDetails为false</span>
<span class="token comment">// 组件每次重新渲染，组件的函数体就会执行，</span>
<span class="token comment">// 以下代码会报错(Too many re-renders. )</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>totalAmount <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">// 购物车已经被清空</span>
 <span class="token function">setShowDetails</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="react-strictmode" tabindex="-1"><a class="header-anchor" href="#react-strictmode" aria-hidden="true">#</a> React.StrictMode</h2><p>编写React组件时，我们要极力的避免组件中出现那些会产生“副作用”的代码。同时，如果你的React使用了严格模式，也就是在React中使用了<code>React.StrictMode</code>标签，那么React会非常“智能”的去检查你的组件中是否写有副作用的代码，当然这个智能是加了引号的，我们来看看React官网的文档是如何说明的：</p><p>Strict mode can’t automatically detect side effects for you, but it can help you spot them by making them a little more deterministic. This is done by intentionally double-invoking the following functions:</p><ul><li>Class component <code>constructor</code>, <code>render</code>, and <code>shouldComponentUpdate</code> methods</li><li>Class component static <code>getDerivedStateFromProps</code> method</li><li>Function component bodies</li><li>State updater functions (the first argument to <code>setState</code>)</li><li>Functions passed to <code>useState</code>, <code>useMemo</code>, or <code>useReducer</code></li></ul><p>上文的关键字叫做“double-invoking”即重复调用，这句话是什么意思呢？大概意思就是，React并不能自动替你发现副作用，但是它会想办法让它显现出来，从而让你发现它。那么它是怎么让你发现副作用的呢？React的严格模式，在处于开发模式下，会主动的重复调用一些函数，以使副作用显现。所以在处于开发模式且开启了React严格模式时，这些函数会被调用两次：</p><p>类组件的的 <code>constructor</code>, <code>render</code>, 和 <code>shouldComponentUpdate</code> 方法<br> 类组件的静态方法 <code>getDerivedStateFromProps</code><br> 函数组件的函数体<br> 参数为函数的<code>setState</code><br> 参数为函数的<code>useState</code>, <code>useMemo</code>, or <code>useReducer</code></p><p>重复的调用会使副作用更容易凸显出来，你可以尝试着在函数组件的函数体中调用一个<code>console.log</code>你会发现它会执行两次，如果你的浏览器中安装了React Developer Tools，第二次调用会显示为灰色。</p>`,14),r={href:"https://my-wp.oss-cn-beijing.aliyuncs.com/wp-content/uploads/2022/05/20220512111133423.zip",target:"_blank",rel:"noopener noreferrer"};function u(m,k){const s=i("ExternalLinkIcon");return t(),o("div",null,[l,n("p",null,[e("如果你无法通过浏览器正常安装"),n("a",r,[e("React Developer Tools"),c(s)]),e("可以通过点击这里下载。v")])])}const h=a(d,[["render",u],["__file","37-Too-many-re-renders和React-StrictMode.html.vue"]]);export{h as default};
